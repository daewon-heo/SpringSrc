- 스프링 트랜잭션 -
jdbc, mybatis에서 각각 Connection객체, SqlSession객체에 대해서 commit/rollback을 했던 것과 달리
spring에서는 트랜잭션 관리자가 처리하게 됨(IoC)

- 스프링 트랜잭션 방식 -
1. Declarative Transaction : 선언적 트랜잭션(xml에 선언)
    * <tx:method> 에서는 propagation 애트리뷰트 값으로 지정
    
        <tx:advice>
            <tx:attributes>
                <tx:method name="..."
                        read-only="..."
                        isolation="..."
                        propagation="..."
                        timeout="..."
                        rollback-for="..."
                        no-rollback-for="..." />
            </tx:attributes>
        </tx:advice>

2. Programmatic Transaction :  프로그래밍적 트랜잭션 (@Transactional 어노테이션)
    * @Transactional 에서는 propagation 앨리먼트로 지정

        @Transactional(readOnly=...,
                isolation=...,
                propagation=...,
                timeout=...,
                rollbackFor=..., rollbackForClassName=...,
                noRollbackFor=..., noRollbackForClassName=...)

- 트랜잭션 Propagation -
 트랜잭션은 DB에서 하나의 일 처리 단위를 뜻한다. 이에 Propagation(전파) 속성은
 트랜잭션을 직접 시작할 것인지, 기존 트랜잭션에 참가 할 것인지 등을 통해
 현재 처리하는 일의 경계에 가변성을 부여한다.

  - Propagation 속성 종류 -
  1. REQUIRED
    기본 속성이다. 모든 트랜잭션 매니저가 지원하며, 대개 이 속성이면 충분하다. 미리 시작된 트랜잭션이 있으면 참여하고 없으면 새로 시작한다. 
   자연스럽고 간단한 트랜잭션 전파 방식이지만 사용해보면 매우 강력하고 유용하다는 사실을 알 수 있다. 하나의 트랜잭션이 시작된 후에 다른 트랜잭션 경계가 설정된 메소드를 호출하면 자연스럽게 같은 트랜잭션으로 묶인다.

  2. SUPPORTS
    이미 시작된 트랜잭션이 있으면 참여하고 그렇지 않으면 트랜잭션 없이 진행하게 만든다.
   트랜잭션이 없긴 하지만 해당 경계 안에서 Connection이나 SqlSession 등을 공유할 수 있다.

  3. MANDATORY
    REQUIRED와 비슷하게 이미 시작된 트랜잭션이 있으면 참여한다. 
   하지만 다른 점은 트랜잭션이 시작된 것이 없으면 새로 시작하는 대신 예외를 발생시킨다는 것.
   혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우에 사용한다.

  4. REQUIRES_NEW
    항상 새로운 트랜잭션을 시작한다. 이미 진행 중인 트랜잭션이 있으면 트랜잭션을 잠시 보류시킨다.
   JTA 트랜잭션 매니저를 사용한다면 서버의 트랜잭션 매니저에 트랜잭션 보류가 가능하도록 설정되어 있어야 한다.

  5. NOT_SUPPORTED
    트랜잭션을 사용하지 않게 한다. 이미 진행 중인 트랜잭션이 있으면 보류시킨다.

  6. NEVER
    트랜잭션을 사용하지 않도록 강제한다. 
   이미 진행 중인 트랜잭션도 존재하면 안되며, 있다면 예외를 발생시킨다.

   7. NESTED
    이미 진행중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다. 
   중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것이다. 
   하지만 독립적인 트랜잭션을 만드는 REQUIRES_NEW와는 다르다.


- 트랜잭션 격리 Isolation -
  트랜잭션 격리수준은 동시에 여러 트랜잭션이 진행될 때 트랜잭션의 작업 결과를 
  다른 트랜잭션에게 어떻게 적용할 것인지를 결정하는 기준이다. 
  스프링은 다음 다섯 가지 격리수준 속성을 지원한다.

  1. DEFAULT
    사용하는 데이터 액세스 기술 또는 DB 드라이버의 디폴트 설정을 따른다. 
   보통 드라이버의 격리수준은 DB의 격리수준을 따르는게 일반적이다. 대부분의 DB는 
   READ_COMMITTED를 기본 격리수준으로 갖는다. 하지만 일부 DB는 디폴트 값이 다른 
   경우도 있으므로 DEFAULT를 사용할 경우에는 드라이버와 DB의 문서를 참고해서 
   디폴트 격리수준을 확인해야 한다.

  2. READ_UNCOMMITTED
    가장 낮은 격리수준이다. 하나의 트랜잭션이 커밋되기 전에 그 변화가 다른 트랜잭션에 그대로 노출되는 문제가 있다.
   하지만 가장 빠르기 때문에 데이터의 일관성이 조금 떨어지더라도 성능을 극대화할 때 의도적으로 사용하기도 한다.

  3. READ_COMMITTED
    실제로 가장 많이 사용되는 격리수준이다. 물론 스프링에서는 DEFAULT로 설정해둬도
    DB의 기본 격리수준을 따라서 READ_COMMITTED로 동작하는 경우가 대부분이므로 
   명시적으로 설정하지 않기도 한다. READ_UNCOMMITTED와 달리 다른 트랜잭션이 커밋하지 
   않은 정보는 읽을 수 없다. 대신 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 있다. 
   이 때문에 처음 트랜잭션이 같은 로우를 읽을 경우 다른 내용이 발견될 수 있다.

  4. REPEATABLE_READ
    하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정하는 것을 막아준다. 
   하지만 새로운 로우를 추가하는 것은 제한하지 않는다. 따라서 SELECT로 조건에 맞는 
   로우를 전부 가져오는 경우 트랜잭션이 끝나기 전에 추가된 로우가 발견될 수 있다.

  5. SERIALIZABLE
    가장 강력한 트랜잭션 격리수준이다. 이름 그대로 트랜잭션을 순차적으로 진행시켜 
   주기 때문에 여러 트랜잭션이 동시에 같은 테이블의 정보를 액세스하지 못한다. 
   가장 안전한 격리수준이지만 가장 성능이 떨어지기 때문에 극단적인 안전한 작업이 
   필요한 경우가 아니라면 자주 사용되지 않는다.

 - 트랜잭션 제한시간(timeout) -
  이 속성을 이용하면 트랜잭션에 제한시간을 지정할 수 있다. 
  값은 초 단위로 지정한다. 디폴트는 트랜잭션 시스템의 제한시간을 따르는 것이다. 
  트랜잭션 제한시간을 직접 지정하는 경우 이 기능을 지원하지 못하는 
  일부 트랜잭션 매니저는 예외를 발생시킬 수 있다.

 - 읽기전용 트랜잭션(read-only, readOnly) -
  트랜잭션을 읽기 전용으로 설정할 수 있다. 성능을 최적화하기 위해 사용할 수도 있고
  특정 트랜잭션 작업 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용할 수도 있다. 
  트랜잭션을 준비하면서 읽기 전용 속성이 트랜잭션 매니저에게 전달된다. 
  그에 따라 트랜잭션 매니저가 적절한 작업을 수행한다. 그런데 일부 트랜잭션 매니저의 경우 읽기전용
  속성을 무시하고 쓰기 작업을 허용할 수도 있기 때문에 주의해야 한다. 
  일반적으로 읽기 전용 트랜잭션이 시작된 이후 INSERT, UPDATE, DELETE 같은 쓰기 작업이 진행되면 
  예외가 발생한다. 

 - 트랜잭션 커밋 예외 - 
  2. noRollbackFor, noRollbackForClassName
   rollback-for 속성과는 반대로 기본적으로는 롤백 대상인 런타임 예외를 
  트랜잭션 커밋 대상으로 지정해 준다.

** 
  세밀한 트랜잭션 속성 지정이 필요한 경우에는 @Transactional 을 사용하는 편이 좋다. 
단 트랜잭션 속성이 전체적으로 어떻게 지정되어 있는지 한눈에 보기 힘들다는 단점이 있고,
개발자가 코드를 만들 때 트랜잭션 속성을 실수로 잘못 지정하는 등의 위험이 있기 때문에 
사전에 트랜잭션 속성 지정에 관한 정책이나 가이드라인을 잘 만들어 둬야 한다.